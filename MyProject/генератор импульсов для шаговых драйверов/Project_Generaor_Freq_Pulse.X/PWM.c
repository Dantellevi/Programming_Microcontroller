#include "PWM.h"


long int Freq=5000;        //частота генерации ШИМ
int FreqTim=1;


/*
 ============================Функция задания частоты=========
 */
void FreqSet(long int Fr)
{
    Freq=Fr;
    PR2=(_XTAL_FREQ/(Freq*4*TMR2PRESCALE))-1;//обновляем значение периода
    
}


/*
 ============================Функция инициализации ШИМ=============
 */
void PWM_Init(void)
{
    PR2=(_XTAL_FREQ/(Freq*4*TMR2PRESCALE))-1;//значение периода импульса
   
    //------------вкл. PWM режим--------
    CCP1M2=1;
    CCP1M3=1;
    //-------------------------------------
    
    //--------------Устанавливаем предделитель таймера------------
    T2CKPS0=1;
    T2CKPS1=0;
    //------------------------------------------------------------
    TRISC2=0;   //конфигурирум пин CCP модуля на выход
    TMR2ON = 1;//вкл. таймер
}

/*
 ===========================Функция начала генерирования сигнала===========
 */
void Start_Generator(void)
{
    //------------вкл. PWM режим--------
    CCP1M2=1;
    CCP1M3=1;
    //-------------------------------------
}

/*
 ===========================Функция остановки генерирования сигнала===========
 */
void Stop_Generator(void)
{
    //------------вкл. PWM режим--------
    CCP1M2=0;
    CCP1M3=0;
    //-------------------------------------
}


/*
 =======================Функция устанвки значения ШИМ===================
 */
void PWM_Value(uint16_t value)
{
    if(value<1023)
    {
        value=((float)value/1023)*(_XTAL_FREQ/(Freq*TMR2PRESCALE));
        CCP1X=value&1; //save 1 bit
        CCP1Y=value&2; //save bit 0
        CCPR1L=value>>2;//save other 8 bits
        
    }
}



/*
 ==========================Функция инициализации 16-битного таймера===========
 */
void Timer1_init(void)
{
    /*
     Расчет таймера :
     *  выберем делитель на 2
     * 
     * (1000000/4)/8=31250
     * 
     * ttic=1/31250=3.2*10-5 с      -один тик таймера 
     * 
     *t- необходимое расчитываемое частота : 0.5Гц-1000Гц=2с-1мс
     * 
     * количество тиков необходимое для отсчета :
     * n=t/ttic=2/3ю2e-5 с=62500
     * n=t/ttic=1mc/3ю2e-5 с=31.25
     * 
     * 
     * 500Гц
     * 1/500=0.002
     * n=0.002/3.2x10-5=
     */
    
    
    
    //=================================Устанавливаем предделитель на 8=====================
    T1CKPS0=1;
    T1CKPS1=1;
    //==========================================================================
     //=================================Вкл. тактирование таймера============================
    T1OSCEN=1;
    TMR1CS=0;       //работаем от внутреннего источника т.е. Fcpu/4
    
    GIE=1;      //вкл. глобальные прерывания
    TMR1IE=1;       //вкл. перерывания по переполнению
    PEIE=1;
    TMR1=0x0000;
    
    TRISC2=0;
    PORTCbits.RC2=0;
   
}


/*
 ===========================включаем таймер=======================
 */
void Start_Timer(void)
{
    TMR1ON=1;       //включаем таймер
}

/*
 ==========================выключаем таймер========================
 */
void Stop_Timer(void)
{
    TMR1ON=0;       //выключаем таймер
}



/*
 * ==================================Установка частоты генерации импульсов==========
 */
void Set_Freq_Value(unsigned int value)
{
        float val;
        val=1/(float)value;
        FreqTim=(unsigned int)(65535-(val/0.000032)+7);
    
}

/*
 ===========Функция считывания значения с АЦП и преобразование в частоту========
 */
uint16_t ReadValue(void)
{
    Set_Freq_Value(ADC_Read(ADCCHannel_0));
    return ADC_Read(ADCCHannel_0);
}

/*
 ================================Обработчик прерываний========================
 */
void interrupt CallBack(void)
{
    if(TMR1IF==1)
    {
        Strob();
        TMR1=FreqTim;
        
        TMR1IF=0;
    }
    
}


/*
 ====================================генерируем импульс====================
 */
void Strob(void)
{
    PORTCbits.RC2=1;
    asm("nop");asm("nop");asm("nop");
    asm("nop");asm("nop");asm("nop");
    asm("nop");asm("nop");asm("nop");
    asm("nop");asm("nop");asm("nop");
    asm("nop");asm("nop");asm("nop");
    asm("nop");asm("nop");asm("nop");
    asm("nop");asm("nop");asm("nop");
    PORTCbits.RC2=0;
}






